<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NamuPaiai_Wasserstandsanzeige_MQTT: Testing Arduino ESP8266 Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NamuPaiai_Wasserstandsanzeige_MQTT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Testing Arduino ESP8266 Core </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Testing on host</h2>
<p>Some features of this project can be tested by compiling and running the code on the PC, rather than running it on the ESP8266. Tests and testing infrastructure for such features is located in <code>tests/host</code> directory of the project.</p>
<p>Some hardware features, such as Flash memory and <a class="el" href="class_hardware_serial.html">HardwareSerial</a>, can be emulated on the PC. Others, such as network, WiFi, and other hardware (SPI, I2C, timers, etc) are not yet emulated. This limits the amount of features which can be tested on the host.</p>
<h3>Adding a test case</h3>
<p>Tests are written in C++ using <a href="https://github.com/catchorg/Catch2">Catch framework</a>.</p>
<p>See .cpp files under tests/host/core/ for a few examples how to write test cases.</p>
<p>When adding new test files, update <code>TEST_CPP_FILES</code> variable in tests/host/Makefile to compile them.</p>
<p>If you want to add emulation of a certain feature, add it into tests/host/common/ directory.</p>
<h3>Running test cases</h3>
<p><b>NOTE!</b> The test-on-host environment is dependent on some submodules. Make sure to run <code>git submodule update --init</code> before running any test.</p>
<p>To run test cases, go to tests/host/ directory and run <code>make</code>. This will compile and run the tests.</p>
<p>If all tests pass, you will see "All tests passed" message and the exit code will be 0.</p>
<p>Additionally, test coverage info will be generated using <code>gcov</code> tool. You can use some tool to analyze coverage information, for example <code>lcov</code>: </p><pre class="fragment">lcov -c -d . -d ../../cores/esp8266 -o test.info
genhtml -o html test.info
</pre><p>This will generate an HTML report in <code>html</code> directory. Open html/index.html in your browser to see the report.</p>
<p><b>Note to macOS users:</b> you will need to install GCC using Homebrew or MacPorts. Before running <code>make</code>, set <code>CC</code>, <code>CXX</code>, and <code>GCOV</code> variables to point to GCC tools you have installed. For example, when installing gcc-5 using Homebrew: </p><pre class="fragment">export CC=gcc-5
export CXX=g++-5
export GCOV=gcov-5
</pre><p>When running <code>lcov</code> (which you also need to install), specify <code>gcov</code> binary using <code>--gcov-tool $(which $GCOV)</code> (assuming you have already set <code>GCOV</code> environment variable).</p>
<h2>Testing on device</h2>
<p>Most features and libraries of this project can not be tested on host. Therefore testing on an ESP8266 device is required. Such tests and the test infrastructure are located in tests/device directory of this project.</p>
<h3>Test cases</h3>
<p>Tests are written in the form of Arduino sketches, and placed into tests/device/test_xxx directories. These tests are compiled using Arduino IDE, so test file name should match the name of the directory it is located in (e.g. test_foobar/test_foobar.ino). Tests use a very simple BSTest library, which handles test registration and provides <code>TEST_CASE</code>, <code>CHECK</code>, <code>REQUIRE</code>, and <code>FAIL</code> macros, similar to <a href="https://github.com/catchorg/Catch2">Catch</a>.</p>
<p><em>Note: we should migrate to <a class="el" href="namespace_catch.html">Catch</a> framework with a custom runner.</em></p>
<p>Here is a simple test case written with BSTest:</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">#include &lt;BSTest.h&gt;</div><div class="line">#include &lt;test_config.h&gt;</div><div class="line"></div><div class="line">BS_ENV_DECLARE();</div><div class="line"></div><div class="line">void setup()</div><div class="line">{</div><div class="line">    Serial.begin(115200);</div><div class="line">    BS_RUN(Serial);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line">TEST_CASE(&quot;this test runs successfully&quot;, &quot;[bs]&quot;)</div><div class="line">{</div><div class="line">    CHECK(1 + 1 == 2);</div><div class="line">    REQUIRE(2 * 2 == 4);</div><div class="line">}</div></div><!-- fragment --><p>BSTest is a header-only library, so necessary static data is injected into the sketch using <code><a class="el" href="test_8cpp.html#adcb5d4c82d19f33df796547712f785a3">BS_ENV_DECLARE()</a>;</code> macro.</p>
<p><code><a class="el" href="_b_s_test_8h.html#a42b9334d80d61737ddee6b816a71b3d4">BS_RUN(Serial)</a></code> passes control to the test runner, which uses <code>Serial</code> stream to communicate with the host. If you need to do any preparation before starting tests, for example connect to an AP, do this before calling <code>BS_RUN</code>.</p>
<p><code>TEST_CASE</code> macro defines a test case. First argument is human-readable test name, second contains optional set of tags (identifiers with square brackets). Currently only one tag has special meaning: <code>[.]</code> can be used to mark the test case as ignored. Such tests will not be skipped by the test runner (see below).</p>
<h3>Test execution</h3>
<p>Once <code>BS_RUN</code> is called, BSTest library starts by printing the <em>menu</em>, i.e. the list of tests defined in the sketch. For example:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt;&gt;&gt;bs_test_menu_begin</div><div class="line">&gt;&gt;&gt;&gt;&gt;bs_test_item id=1 name=&quot;this test runs successfully&quot; desc=&quot;[bs]&quot;</div><div class="line">&gt;&gt;&gt;&gt;&gt;bs_test_menu_end</div></div><!-- fragment --><p>Then it waits for the test index to be sent by the host, followed by newline.</p>
<p>Once the line number is received, the test is executed, and feedback is printed: </p><div class="fragment"><div class="line">&gt;&gt;&gt;&gt;&gt;bs_test_start file=&quot;arduino-esp8266/tests/device/test_tests/test_tests.ino&quot; line=13 name=&quot;this test runs successfully&quot; desc=&quot;[bs]&quot;</div><div class="line">&gt;&gt;&gt;&gt;&gt;bs_test_end line=0 result=1 checks=2 failed_checks=0</div></div><!-- fragment --><p>Or, in case the test fails: </p><div class="fragment"><div class="line">&gt;&gt;&gt;&gt;&gt;bs_test_start file=&quot;arduino-esp8266/tests/device/test_tests/test_tests.ino&quot; line=19 name=&quot;another test which fails&quot; desc=&quot;[bs][fail]&quot;</div><div class="line">&gt;&gt;&gt;&gt;&gt;bs_test_check_failure line=22</div><div class="line">&gt;&gt;&gt;&gt;&gt;bs_test_check_failure line=24</div><div class="line">&gt;&gt;&gt;&gt;&gt;bs_test_end line=0 result=0 checks=4 failed_checks=2</div></div><!-- fragment --><p>BSTest library also contains a Python script which can "talk" to the ESP8266 board and run the tests, <a class="el" href="runner_8py.html">tests/device/libraries/BSTest/runner.py</a>. Normally it is not necessary to use this script directly, as the top level Makefile in tests/device/ directory can call it automatically (see below).</p>
<h3>Test configuration</h3>
<p>Some tests need to connect to WiFi AP or to the PC running the tests. In the test code, this configuration is read from environment variables (the ones set using C <code>getenv</code>/<code>setenv</code> functions). There are two ways environment variables can be set.</p>
<ul>
<li>Environment variables which apply to all or most of the tests can be defined in <code>tests/device/test_env.cfg</code> file. This file is not present in Git by default. Make a copy of <code>tests/device/test_env.cfg.template</code> and change the values to suit your environment.</li>
<li>Environment variables which apply to a specific test can be set dynamically by the <code>setup</code> host side helper (see section below). This is done using <code>setenv</code> function defined in <code><a class="el" href="namespacemock__decorators.html">mock_decorators</a></code>.</li>
</ul>
<p>Environment variables can also be used to pass some information from the test code to the host side helper. To do that, test code can set an environment variable using <code>setenv</code> C function. Then the <code>teardown</code> host side helper can obtain the value of that variable using <code>request_env</code> function defined in <code><a class="el" href="namespacemock__decorators.html">mock_decorators</a></code>.</p>
<p>A SPIFFS filesystem may be generated on the host and uploade before a test by including a file called <code><a class="el" href="make__spiffs_8py.html">make_spiffs.py</a></code> in the individual test directory.</p>
<h3>Building and running the tests</h3>
<p>Makefile in tests/device/ directory handles compiling, uploading, and executing test cases.</p>
<p>Here are some of the supported targets:</p>
<ul>
<li><code>virtualenv</code>: prepares Python virtual environment inside tests/device/libaries/BSTest/virtualenv/. This has to be run once on each computer where tests are to be run. This target will use <code>pip</code> to install several Python libraries required by the test runner (see tests/device/libaries/BSTest/requirements.txt).</li>
<li><p class="startli"><code>test_xxx/test_xxx.ino</code>: compiles, uploads, and runs the tests defined in <code>test_xxx/test_xxx.ino</code> sketch. Some extra options are available, these can be passed as additional arguments to <code>make</code>:</p><ul>
<li><code>NO_BUILD=1</code>: don't compile the test.</li>
<li><code>NO_UPLOAD=1</code>: don't upload the test.</li>
<li><code>NO_RUN=1</code>: don't run the test.</li>
<li><code>V=1</code>: enable verbose output from compilation, upload, and test runner.</li>
</ul>
<p class="startli">For example, <code>make test_newlib/test_newlib.ino V=1</code> will compile, upload, and run all tests defined in <code>test_newlib/test_newlib.ino</code>.</p>
<p class="startli">For each test sketch, test results are stored in <code>tests/device/.build/test_xxx.ino/test_result.xml</code>. This file is an xUnit XML file, and can be read by a variety of tools, such as Jenkins.</p>
</li>
<li><code>test_report</code>: Generate HTML test report from xUnit XML files produced by test runs.</li>
<li><code>all</code> (or just <code>make</code> without a target): Run tests from all the .ino files, and generate HTML test report.</li>
</ul>
<h3>Host-side helpers</h3>
<p>Some tests running on the device need a matching part running on the host. For example, HTTP client test might need a web server running on the host to connect to. TCP server test might need to be connected to by TCP client running on the host. To support such use cases, for each test file, an optional Python test file can be provided. This Python file defines setup and teardown functions which have to be run before and after the test is run on the device. <code>setup</code> and <code>teardown</code> decorators bind setup/teardown functions to the test with specified name:</p>
<div class="fragment"><div class="line">from mock_decorators import setup, teardown, setenv, request_env</div><div class="line"></div><div class="line">@setup(&#39;WiFiClient test&#39;)</div><div class="line">def setup_wificlient_test(e):</div><div class="line">    # create a TCP server</div><div class="line">    # pass environment variable to the test</div><div class="line">    setenv(e, &#39;SERVER_PORT&#39;, &#39;10000&#39;)</div><div class="line">    setenv(e, &#39;SERVER_IP&#39;, repr(server_ip))</div><div class="line"></div><div class="line">@teardown(&#39;WiFiClient test&#39;)</div><div class="line">def teardown_wificlient_test(e):</div><div class="line">    # delete TCP server</div><div class="line">    # request environment variable from the test, compare to the expected value</div><div class="line">    read_bytes = request_env(e, &#39;READ_BYTES&#39;)</div><div class="line">    assert(read_bytes == &#39;4096&#39;)</div></div><!-- fragment --><p>Corresponding test code might look like this:</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line"></div><div class="line">TEST_CASE(&quot;WiFiClient test&quot;, &quot;[wificlient]&quot;)</div><div class="line">{</div><div class="line">    const char* server_ip = getenv(&quot;SERVER_IP&quot;);</div><div class="line">    int server_port = (int) strtol(getenv(&quot;SERVER_PORT&quot;), NULL, 0);</div><div class="line"></div><div class="line">    WiFiClient client;</div><div class="line">    REQUIRE(client.connect(server_ip, server_port));</div><div class="line"></div><div class="line">    // read data from server</div><div class="line">    // ...</div><div class="line"></div><div class="line">    // Save the result back so that host side helper can read it</div><div class="line">    setenv(&quot;READ_BYTES&quot;, String(read_bytes).c_str(), 1);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
