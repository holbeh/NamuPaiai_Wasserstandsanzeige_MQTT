<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NamuPaiai_Wasserstandsanzeige_MQTT: /home/kloenk/.platformio/packages/framework-arduinoespressif8266/tools/sdk/ssl/bearssl/src/ssl/ssl_io.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NamuPaiai_Wasserstandsanzeige_MQTT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_f00e418d171e49b17445b65571a8f367.html">.platformio</a></li><li class="navelem"><a class="el" href="dir_9c890f64469c51741ed59309dac154b6.html">packages</a></li><li class="navelem"><a class="el" href="dir_2f2b8fdc9e3a4daa689fa559edc2cfe3.html">framework-arduinoespressif8266</a></li><li class="navelem"><a class="el" href="dir_9cc1b10cf4616ff2fa9e7a7f19cbe10c.html">tools</a></li><li class="navelem"><a class="el" href="dir_b406ea4600393cb66f11707d56d93d0b.html">sdk</a></li><li class="navelem"><a class="el" href="dir_0b0a637845ba43964bde89b86ab846e9.html">ssl</a></li><li class="navelem"><a class="el" href="dir_4fddf90c78890527e4e584bd7ee88b52.html">bearssl</a></li><li class="navelem"><a class="el" href="dir_021a61e1412f675177b873e5ec8bda07.html">src</a></li><li class="navelem"><a class="el" href="dir_4e9015ebc0e7f6b4f1f52ccfecac99a9.html">ssl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ssl_io.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="inner_8h_source.html">inner.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab9f7303a713df06e676fc10c6f1de769"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ssl__io_8c.html#ab9f7303a713df06e676fc10c6f1de769">br_sslio_init</a> (<a class="el" href="structbr__sslio__context.html">br_sslio_context</a> *ctx, <a class="el" href="structbr__ssl__engine__context.html">br_ssl_engine_context</a> *engine, int(*low_read)(void *read_context, unsigned char *data, size_t len), void *read_context, int(*low_write)(void *write_context, <a class="el" href="cdefs_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> unsigned char *data, size_t len), void *write_context)</td></tr>
<tr class="memdesc:ab9f7303a713df06e676fc10c6f1de769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a simplified I/O wrapper context.  <a href="#ab9f7303a713df06e676fc10c6f1de769">More...</a><br /></td></tr>
<tr class="separator:ab9f7303a713df06e676fc10c6f1de769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0e0539c06cbdaa0aace69bf2ec7b4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ssl__io_8c.html#a5f0e0539c06cbdaa0aace69bf2ec7b4f">br_sslio_read</a> (<a class="el" href="structbr__sslio__context.html">br_sslio_context</a> *ctx, void *dst, size_t len)</td></tr>
<tr class="memdesc:a5f0e0539c06cbdaa0aace69bf2ec7b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some application data from a SSL connection.  <a href="#a5f0e0539c06cbdaa0aace69bf2ec7b4f">More...</a><br /></td></tr>
<tr class="separator:a5f0e0539c06cbdaa0aace69bf2ec7b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29719c573f34e275cb54674eda02750f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ssl__io_8c.html#a29719c573f34e275cb54674eda02750f">br_sslio_read_all</a> (<a class="el" href="structbr__sslio__context.html">br_sslio_context</a> *ctx, void *dst, size_t len)</td></tr>
<tr class="memdesc:a29719c573f34e275cb54674eda02750f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read application data from a SSL connection.  <a href="#a29719c573f34e275cb54674eda02750f">More...</a><br /></td></tr>
<tr class="separator:a29719c573f34e275cb54674eda02750f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547056a3f627a8824ae7fadd0e7cebe0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ssl__io_8c.html#a547056a3f627a8824ae7fadd0e7cebe0">br_sslio_write</a> (<a class="el" href="structbr__sslio__context.html">br_sslio_context</a> *ctx, <a class="el" href="cdefs_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> void *src, size_t len)</td></tr>
<tr class="memdesc:a547056a3f627a8824ae7fadd0e7cebe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write some application data unto a SSL connection.  <a href="#a547056a3f627a8824ae7fadd0e7cebe0">More...</a><br /></td></tr>
<tr class="separator:a547056a3f627a8824ae7fadd0e7cebe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15e35188cef68bbb30da5870e98af2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ssl__io_8c.html#ae15e35188cef68bbb30da5870e98af2c">br_sslio_write_all</a> (<a class="el" href="structbr__sslio__context.html">br_sslio_context</a> *ctx, <a class="el" href="cdefs_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> void *src, size_t len)</td></tr>
<tr class="memdesc:ae15e35188cef68bbb30da5870e98af2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write application data unto a SSL connection.  <a href="#ae15e35188cef68bbb30da5870e98af2c">More...</a><br /></td></tr>
<tr class="separator:ae15e35188cef68bbb30da5870e98af2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52208abb53d9b0f0ac3a16186f060283"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ssl__io_8c.html#a52208abb53d9b0f0ac3a16186f060283">br_sslio_flush</a> (<a class="el" href="structbr__sslio__context.html">br_sslio_context</a> *ctx)</td></tr>
<tr class="memdesc:a52208abb53d9b0f0ac3a16186f060283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush pending data.  <a href="#a52208abb53d9b0f0ac3a16186f060283">More...</a><br /></td></tr>
<tr class="separator:a52208abb53d9b0f0ac3a16186f060283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb29f4ff8874c922c44689c3de0349a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ssl__io_8c.html#afb29f4ff8874c922c44689c3de0349a5">br_sslio_close</a> (<a class="el" href="structbr__sslio__context.html">br_sslio_context</a> *ctx)</td></tr>
<tr class="memdesc:afb29f4ff8874c922c44689c3de0349a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the SSL connection.  <a href="#afb29f4ff8874c922c44689c3de0349a5">More...</a><br /></td></tr>
<tr class="separator:afb29f4ff8874c922c44689c3de0349a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="afb29f4ff8874c922c44689c3de0349a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb29f4ff8874c922c44689c3de0349a5">&#9670;&nbsp;</a></span>br_sslio_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int br_sslio_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbr__sslio__context.html">br_sslio_context</a> *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the SSL connection. </p>
<p>This call runs the SSL closure protocol (sending a <code>close_notify</code>, receiving the response <code>close_notify</code>). When it returns, the SSL connection is finished. It is still up to the caller to manage the possible transport-level termination, if applicable (alternatively, the underlying transport stream may be reused for non-SSL messages).</p>
<p>Returned value is 0 on success, -1 on error. A failure by the peer to process the complete closure protocol (i.e. sending back the <code>close_notify</code>) is an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>SSL wrapper context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or -1 on error. </dd></dl>

</div>
</div>
<a id="a52208abb53d9b0f0ac3a16186f060283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52208abb53d9b0f0ac3a16186f060283">&#9670;&nbsp;</a></span>br_sslio_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int br_sslio_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbr__sslio__context.html">br_sslio_context</a> *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush pending data. </p>
<p>This call makes sure that any buffered application data in the provided context (including the wrapped SSL engine) has been sent to the transport medium (i.e. accepted by the <code>low_write()</code> callback method). If there is no such pending data, then this function does nothing (and returns a success, i.e. 0).</p>
<p>If the underlying transport medium has its own buffers, then it is up to the caller to ensure the corresponding flushing.</p>
<p>Returned value is 0 on success, -1 on error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>SSL wrapper context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or -1 on error. </dd></dl>

</div>
</div>
<a id="ab9f7303a713df06e676fc10c6f1de769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f7303a713df06e676fc10c6f1de769">&#9670;&nbsp;</a></span>br_sslio_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void br_sslio_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbr__sslio__context.html">br_sslio_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbr__ssl__engine__context.html">br_ssl_engine_context</a> *&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *read_context, unsigned char *data, size_t len)&#160;</td>
          <td class="paramname"><em>low_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>read_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *write_context, <a class="el" href="cdefs_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> unsigned char *data, size_t len)&#160;</td>
          <td class="paramname"><em>low_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>write_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a simplified I/O wrapper context. </p>
<p>The simplified I/O wrapper offers a simpler read/write API for a SSL engine (client or server), using the provided callback functions for reading data from, or writing data to, the transport medium.</p>
<p>The callback functions have the following semantics:</p>
<ul>
<li>Each callback receives an opaque context value (of type <code>void *</code>) that the callback may use arbitrarily (or possibly ignore).</li>
<li><code>low_read()</code> reads at least one byte, at most <code>len</code> bytes, from the transport medium. Read bytes shall be written in <code>data</code>.</li>
<li><code>low_write()</code> writes at least one byte, at most <code>len</code> bytes, unto the transport medium. The bytes to write are read from <code>data</code>.</li>
<li>The <code>len</code> parameter is never zero, and is always lower than 20000.</li>
<li>The number of processed bytes (read or written) is returned. Since that number is less than 20000, it always fits on an <code>int</code>.</li>
<li>On error, the callbacks return -1. Reaching end-of-stream is an error. Errors are permanent: the SSL connection is terminated.</li>
<li>Callbacks SHOULD NOT return 0. This is tolerated, as long as callbacks endeavour to block for some non-negligible amount of time until at least one byte can be sent or received (if a callback returns 0, then the wrapper invokes it again immediately).</li>
<li>Callbacks MAY return as soon as at least one byte is processed; they MAY also insist on reading or writing <em>all</em> requested bytes. Since SSL is a self-terminated protocol (each record has a length header), this does not change semantics.</li>
<li>Callbacks need not apply any buffering (for performance) since SSL itself uses buffers.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>wrapper context to initialise. </td></tr>
    <tr><td class="paramname">engine</td><td>SSL engine to wrap. </td></tr>
    <tr><td class="paramname">low_read</td><td>callback for reading data from the transport. </td></tr>
    <tr><td class="paramname">read_context</td><td>context pointer for <code>low_read()</code>. </td></tr>
    <tr><td class="paramname">low_write</td><td>callback for writing data on the transport. </td></tr>
    <tr><td class="paramname">write_context</td><td>context pointer for <code>low_write()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f0e0539c06cbdaa0aace69bf2ec7b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0e0539c06cbdaa0aace69bf2ec7b4f">&#9670;&nbsp;</a></span>br_sslio_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int br_sslio_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbr__sslio__context.html">br_sslio_context</a> *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read some application data from a SSL connection. </p>
<p>If <code>len</code> is zero, then this function returns 0 immediately. In all other cases, it never returns 0.</p>
<p>This call returns only when at least one byte has been obtained. Returned value is the number of bytes read, or -1 on error. The number of bytes always fits on an 'int' (data from a single SSL/TLS record is returned).</p>
<p>On error or SSL closure, this function returns -1. The caller should inspect the error status on the SSL engine to distinguish between normal closure and error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>SSL wrapper context. </td></tr>
    <tr><td class="paramname">dst</td><td>destination buffer for application data. </td></tr>
    <tr><td class="paramname">len</td><td>maximum number of bytes to obtain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes obtained, or -1 on error. </dd></dl>

</div>
</div>
<a id="a29719c573f34e275cb54674eda02750f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29719c573f34e275cb54674eda02750f">&#9670;&nbsp;</a></span>br_sslio_read_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int br_sslio_read_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbr__sslio__context.html">br_sslio_context</a> *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read application data from a SSL connection. </p>
<p>This calls returns only when <em>all</em> requested <code>len</code> bytes are read, or an error is reached. Returned value is 0 on success, -1 on error. A normal (verified) SSL closure before that many bytes are obtained is reported as an error by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>SSL wrapper context. </td></tr>
    <tr><td class="paramname">dst</td><td>destination buffer for application data. </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes to obtain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or -1 on error. </dd></dl>

</div>
</div>
<a id="a547056a3f627a8824ae7fadd0e7cebe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547056a3f627a8824ae7fadd0e7cebe0">&#9670;&nbsp;</a></span>br_sslio_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int br_sslio_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbr__sslio__context.html">br_sslio_context</a> *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdefs_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write some application data unto a SSL connection. </p>
<p>If <code>len</code> is zero, then this function returns 0 immediately. In all other cases, it never returns 0.</p>
<p>This call returns only when at least one byte has been written. Returned value is the number of bytes written, or -1 on error. The number of bytes always fits on an 'int' (less than 20000).</p>
<p>On error or SSL closure, this function returns -1. The caller should inspect the error status on the SSL engine to distinguish between normal closure and error.</p>
<p><b>Important:</b> SSL is buffered; a "written" byte is a byte that was injected into the wrapped SSL engine, but this does not necessarily mean that it has been scheduled for sending. Use <code><a class="el" href="include_2bearssl_2bearssl__ssl_8h.html#aa9514a2c716955bd851ed04eec55a62b" title="Flush pending data.">br_sslio_flush()</a></code> to ensure that all pending data has been sent to the transport medium.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>SSL wrapper context. </td></tr>
    <tr><td class="paramname">src</td><td>source buffer for application data. </td></tr>
    <tr><td class="paramname">len</td><td>maximum number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written, or -1 on error. </dd></dl>

</div>
</div>
<a id="ae15e35188cef68bbb30da5870e98af2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15e35188cef68bbb30da5870e98af2c">&#9670;&nbsp;</a></span>br_sslio_write_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int br_sslio_write_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbr__sslio__context.html">br_sslio_context</a> *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdefs_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write application data unto a SSL connection. </p>
<p>This calls returns only when <em>all</em> requested <code>len</code> bytes have been written, or an error is reached. Returned value is 0 on success, -1 on error. A normal (verified) SSL closure before that many bytes are written is reported as an error by this function.</p>
<p><b>Important:</b> SSL is buffered; a "written" byte is a byte that was injected into the wrapped SSL engine, but this does not necessarily mean that it has been scheduled for sending. Use <code><a class="el" href="include_2bearssl_2bearssl__ssl_8h.html#aa9514a2c716955bd851ed04eec55a62b" title="Flush pending data.">br_sslio_flush()</a></code> to ensure that all pending data has been sent to the transport medium.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>SSL wrapper context. </td></tr>
    <tr><td class="paramname">src</td><td>source buffer for application data. </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or -1 on error. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
