<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NamuPaiai_Wasserstandsanzeige_MQTT: Hooks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NamuPaiai_Wasserstandsanzeige_MQTT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Hooks<div class="ingroups"><a class="el" href="group__lwip__opts.html">Options (lwipopts.h)</a> &raquo; <a class="el" href="group__lwip__opts__infrastructure.html">Infrastructure</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6cc92f5101dd7a0420e18e1f2101abf4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga6cc92f5101dd7a0420e18e1f2101abf4">LWIP_HOOK_UNKNOWN_ETH_PROTOCOL</a>(<a class="el" href="structpbuf.html">pbuf</a>,  <a class="el" href="structnetif.html">netif</a>)&#160;&#160;&#160;<a class="el" href="_2include_2lwipopts_8h.html#a44ed2e676bd99bc3dc7289a07482226b">lwip_unhandled_packet</a>((<a class="el" href="structpbuf.html">pbuf</a>), (<a class="el" href="structnetif.html">netif</a>))</td></tr>
<tr class="separator:ga6cc92f5101dd7a0420e18e1f2101abf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Hooks are undefined by default, define them to a function if you need them. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga6cc92f5101dd7a0420e18e1f2101abf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc92f5101dd7a0420e18e1f2101abf4">&#9670;&nbsp;</a></span>LWIP_HOOK_UNKNOWN_ETH_PROTOCOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_UNKNOWN_ETH_PROTOCOL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpbuf.html">pbuf</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structnetif.html">netif</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="_2include_2lwipopts_8h.html#a44ed2e676bd99bc3dc7289a07482226b">lwip_unhandled_packet</a>((<a class="el" href="structpbuf.html">pbuf</a>), (<a class="el" href="structnetif.html">netif</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_HOOK_FILENAME: Custom filename to #include in files that provide hooks. Declare your hook function prototypes in there, you may also #include all headers providing data types that are need in this file.LWIP_HOOK_TCP_ISN: Hook for generation of the Initial Sequence Number (ISN) for a new TCP connection. The default lwIP ISN generation algorithm is very basic and may allow for TCP spoofing attacks. This hook provides the means to implement the standardized ISN generation algorithm from RFC 6528 (see contrib/adons/tcp_isn), or any other desired algorithm as a replacement. Called from tcp_connect() and tcp_listen_input() when an ISN is needed for a new TCP connection, if TCP support (<a class="el" href="group__lwip__opts__tcp.html#gaa4ed98deb97b77c633cb8870f34c71e9">LWIP_TCP</a>) is enabled.<br />
Signature: u32_t my_hook_tcp_isn(const ip_addr_t* local_ip, u16_t local_port, const ip_addr_t* remote_ip, u16_t remote_port);</p><ul>
<li>it may be necessary to use "struct ip_addr" (ip4_addr, ip6_addr) instead of "ip_addr_t" in function declarations<br />
Arguments:</li>
<li>local_ip: pointer to the local IP address of the connection</li>
<li>local_port: local port number of the connection (host-byte order)</li>
<li>remote_ip: pointer to the remote IP address of the connection</li>
<li>remote_port: remote port number of the connection (host-byte order)<br />
Return value:</li>
<li>the 32-bit Initial Sequence Number to use for the new TCP connection.LWIP_HOOK_IP4_INPUT(pbuf, input_netif):</li>
<li>called from <a class="el" href="include_2lwip_2ip_8h.html#a9feb530a8af39f237202b679b5be04a1">ip_input()</a> (IPv4)</li>
<li>pbuf: received struct pbuf passed to <a class="el" href="include_2lwip_2ip_8h.html#a9feb530a8af39f237202b679b5be04a1">ip_input()</a></li>
<li>input_netif: struct netif on which the packet has been received Return values:</li>
<li>0: Hook has not consumed the packet, packet is processed as normal</li>
<li>!= 0: Hook has consumed the packet. If the hook consumed the packet, 'pbuf' is in the responsibility of the hook (i.e. free it when done).LWIP_HOOK_IP4_ROUTE(dest):</li>
<li>called from <a class="el" href="include_2lwip_2ip_8h.html#a134eb96f764190bd45f97284d1bf3c4f">ip_route()</a> (IPv4)</li>
<li>dest: destination IPv4 address Returns the destination netif or NULL if no destination netif is found. In that case, <a class="el" href="include_2lwip_2ip_8h.html#a134eb96f764190bd45f97284d1bf3c4f">ip_route()</a> continues as normal.LWIP_HOOK_IP4_ROUTE_SRC(dest, src):</li>
<li>source-based routing for IPv4 (see LWIP_HOOK_IP4_ROUTE(), src may be NULL)LWIP_HOOK_ETHARP_GET_GW(netif, dest):</li>
<li>called from <a class="el" href="lwip-esp_8c.html#af52924905839642bd5ce16d8cef17375">etharp_output()</a> (IPv4)</li>
<li>netif: the netif used for sending</li>
<li>dest: the destination IPv4 address Returns the IPv4 address of the gateway to handle the specified destination IPv4 address. If NULL is returned, the netif's default gateway is used. The returned address MUST be directly reachable on the specified netif! This function is meant to implement advanced IPv4 routing together with LWIP_HOOK_IP4_ROUTE(). The actual routing/gateway table implementation is not part of lwIP but can e.g. be hidden in the netif's state argument.LWIP_HOOK_IP6_INPUT(pbuf, input_netif):</li>
<li>called from ip6_input() (IPv6)</li>
<li>pbuf: received struct pbuf passed to ip6_input()</li>
<li>input_netif: struct netif on which the packet has been received Return values:</li>
<li>0: Hook has not consumed the packet, packet is processed as normal</li>
<li>!= 0: Hook has consumed the packet. If the hook consumed the packet, 'pbuf' is in the responsibility of the hook (i.e. free it when done).LWIP_HOOK_IP6_ROUTE(src, dest):</li>
<li>called from ip6_route() (IPv6)</li>
<li>src: sourc IPv6 address</li>
<li>dest: destination IPv6 address Returns the destination netif or NULL if no destination netif is found. In that case, ip6_route() continues as normal.LWIP_HOOK_ND6_GET_GW(netif, dest):</li>
<li>called from nd6_get_next_hop_entry() (IPv6)</li>
<li>netif: the netif used for sending</li>
<li>dest: the destination IPv6 address Returns the IPv6 address of the next hop to handle the specified destination IPv6 address. If NULL is returned, a NDP-discovered router is used instead. The returned address MUST be directly reachable on the specified netif! This function is meant to implement advanced IPv6 routing together with LWIP_HOOK_IP6_ROUTE(). The actual routing/gateway table implementation is not part of lwIP but can e.g. be hidden in the netif's state argument.LWIP_HOOK_VLAN_CHECK(netif, eth_hdr, vlan_hdr):</li>
<li>called from <a class="el" href="lwip-esp_8c.html#a6a10c58b82c56d02c48b3cfa2c2494ff">ethernet_input()</a> if VLAN support is enabled</li>
<li>netif: struct netif on which the packet has been received</li>
<li><a class="el" href="structeth__hdr.html">eth_hdr</a>: struct <a class="el" href="structeth__hdr.html">eth_hdr</a> of the packet</li>
<li>vlan_hdr: struct <a class="el" href="structeth__vlan__hdr.html">eth_vlan_hdr</a> of the packet Return values:</li>
<li>0: Packet must be dropped.</li>
<li>!= 0: Packet must be accepted.LWIP_HOOK_VLAN_SET: Hook can be used to set prio_vid field of vlan_hdr. If you need to store data on per-netif basis to implement this callback, see netif_cd. Called from ethernet_output() if VLAN support (<a class="el" href="group__lwip__opts__arp.html#ga70ce0ecf56cf5fab000134e66d863f90">ETHARP_SUPPORT_VLAN</a>) is enabled.<br />
Signature: s32_t my_hook_vlan_set(struct netif* netif, struct pbuf* pbuf, const struct eth_addr* src, const struct eth_addr* dst, u16_t eth_type);<br />
Arguments:</li>
<li>netif: struct netif that the packet will be sent through</li>
<li>p: struct pbuf packet to be sent</li>
<li>src: source eth address</li>
<li>dst: destination eth address</li>
<li>eth_type: ethernet type to packet to be sent<br />
</li>
</ul>
<p>Return values:</p><ul>
<li>&lt;0: Packet shall not contain VLAN header.</li>
<li>0 &lt;= return value &lt;= 0xFFFF: Packet shall contain VLAN header. Return value is prio_vid in host byte order.LWIP_HOOK_MEMP_AVAILABLE(memp_t_type):</li>
<li>called from <a class="el" href="include_2lwip_2memp_8h.html#a9d30a969401eb0626105950d6e63f3bf">memp_free()</a> when a memp pool was empty and an item is now availableLWIP_HOOK_UNKNOWN_ETH_PROTOCOL(pbuf, netif): Called from <a class="el" href="lwip-esp_8c.html#a6a10c58b82c56d02c48b3cfa2c2494ff">ethernet_input()</a> when an unknown eth type is encountered. Return ERR_OK if packet is accepted, any error code otherwise. Payload points to ethernet header! </li>
</ul>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
