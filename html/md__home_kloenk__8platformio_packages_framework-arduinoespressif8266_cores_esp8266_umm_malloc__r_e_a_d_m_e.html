<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NamuPaiai_Wasserstandsanzeige_MQTT: umm_malloc - Memory Manager For Small(ish) Microprocessors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NamuPaiai_Wasserstandsanzeige_MQTT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">umm_malloc - Memory Manager For Small(ish) Microprocessors </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a memory management library specifically designed to work with the ARM7 embedded processor, but it should work on many other 32 bit processors, as well as 16 and 8 bit devices.</p>
<p>You can even use it on a bigger project where a single process might want to manage a large number of smaller objects, and using the system heap might get expensive.</p>
<h2>Acknowledgements</h2>
<p>Joerg Wunsch and the avr-libc provided the first <a class="el" href="_e_s_p8266_a_v_r_i_s_p_8cpp.html#acf143577800376dd931c059ecc61ba06">malloc()</a> implementation that I examined in detail.</p>
<p><a href="http://www.nongnu.org/avr-libc">http://www.nongnu.org/avr-libc</a></p>
<p>Doug Lea's paper on <a class="el" href="_e_s_p8266_a_v_r_i_s_p_8cpp.html#acf143577800376dd931c059ecc61ba06">malloc()</a> was another excellent reference and provides a lot of detail on advanced memory management techniques such as binning.</p>
<p><a href="http://g.oswego.edu/dl/html/malloc.html">http://g.oswego.edu/dl/html/malloc.html</a></p>
<p>Bill Dittman provided excellent suggestions, including macros to support using these functions in critical sections, and for optimizing realloc() further by checking to see if the previous block was free and could be used for the new block size. This can help to reduce heap fragmentation significantly.</p>
<p>Yaniv Ankin suggested that a way to dump the current heap condition might be useful. I combined this with an idea from plarroy to also allow checking a free pointer to make sure it's valid.</p>
<h2>Background</h2>
<p>The memory manager assumes the following things:</p>
<ol type="1">
<li>The standard POSIX compliant malloc/realloc/free semantics are used</li>
</ol>
<ol type="1">
<li>All memory used by the manager is allocated at link time, it is aligned on a 32 bit boundary, it is contiguous, and its extent (start and end address) is filled in by the linker.</li>
</ol>
<ol type="1">
<li>All memory used by the manager is initialized to 0 as part of the runtime startup routine. No other initialization is required.</li>
</ol>
<p>The fastest linked list implementations use doubly linked lists so that its possible to insert and delete blocks in constant time. This memory manager keeps track of both free and used blocks in a doubly linked list.</p>
<p>Most memory managers use some kind of list structure made up of pointers to keep track of used - and sometimes free - blocks of memory. In an embedded system, this can get pretty expensive as each pointer can use up to 32 bits.</p>
<p>In most embedded systems there is no need for managing large blocks of memory dynamically, so a full 32 bit pointer based data structure for the free and used block lists is wasteful. A block of memory on the free list would use 16 bytes just for the pointers!</p>
<p>This memory management library sees the malloc heap as an array of blocks, and uses block numbers to keep track of locations. The block numbers are 15 bits - which allows for up to 32767 blocks of memory. The high order bit marks a block as being either free or in use, which will be explained later.</p>
<p>The result is that a block of memory on the free list uses just 8 bytes instead of 16.</p>
<p>In fact, we go even one step futher when we realize that the free block index values are available to store data when the block is allocated.</p>
<p>The overhead of an allocated block is therefore just 4 bytes.</p>
<p>Each memory block holds 8 bytes, and there are up to 32767 blocks available, for about 256K of heap space. If that's not enough, you can always add more data bytes to the body of the memory block at the expense of free block size overhead.</p>
<p>There are a lot of little features and optimizations in this memory management system that makes it especially suited to small embedded, but the best way to appreciate them is to review the data structures and algorithms used, so let's get started.</p>
<h2>Detailed Description</h2>
<p>We have a general notation for a block that we'll use to describe the different scenarios that our memory allocation algorithm must deal with:</p>
<div class="fragment"><div class="line">   +----+----+----+----+</div><div class="line">c  |* n |  p | nf | pf |</div><div class="line">   +----+----+----+----+</div></div><!-- fragment --><p>Where:</p>
<ul>
<li>c is the index of this block</li>
<li>* is the indicator for a free block</li>
<li>n is the index of the next block in the heap</li>
<li>p is the index of the previous block in the heap</li>
<li>nf is the index of the next block in the free list</li>
<li>pf is the index of the previous block in the free list</li>
</ul>
<p>The fact that we have forward and backward links in the block descriptors means that <a class="el" href="_e_s_p8266_a_v_r_i_s_p_8cpp.html#acf143577800376dd931c059ecc61ba06">malloc()</a> and <a class="el" href="_e_s_p8266_a_v_r_i_s_p_8cpp.html#a2c6efa7679f8cd9f61af96e105017560">free()</a> operations can be very fast. It's easy to either allocate the whole free item to a new block or to allocate part of the free item and leave the rest on the free list without traversing the list from front to back first.</p>
<p>The entire block of memory used by the heap is assumed to be initialized to 0. The very first block in the heap is special - it't the head of the free block list. It is never assimilated with a free block (more on this later).</p>
<p>Once a block has been allocated to the application, it looks like this:</p>
<div class="fragment"><div class="line">  +----+----+----+----+</div><div class="line">c |  n |  p |   ...   |</div><div class="line">  +----+----+----+----+</div></div><!-- fragment --><p>Where:</p>
<ul>
<li>c is the index of this block</li>
<li>n is the index of the next block in the heap</li>
<li>p is the index of the previous block in the heap</li>
</ul>
<p>Note that the free list information is gone, because it's now being used to store actual data for the application. It would have been nice to store the next and previous free list indexes as well, but that would be a waste of space. If we had even 500 items in use, that would be 2,000 bytes for free list information. We simply can't afford to waste that much.</p>
<p>The address of the <code>...</code> area is what is returned to the application for data storage.</p>
<p>The following sections describe the scenarios encountered during the operation of the library. There are two additional notation conventions:</p>
<p><code>??</code> inside a pointer block means that the data is irrelevant. We don't care about it because we don't read or modify it in the scenario being described.</p>
<p><code>...</code> between memory blocks indicates zero or more additional blocks are allocated for use by the upper block.</p>
<p>And while we're talking about "upper" and "lower" blocks, we should make a comment about adresses. In the diagrams, a block higher up in the picture is at a lower address. And the blocks grow downwards their block index increases as does their physical address.</p>
<p>Finally, there's one very important characteristic of the individual blocks that make up the heap - there can never be two consecutive free memory blocks, but there can be consecutive used memory blocks.</p>
<p>The reason is that we always want to have a short free list of the largest possible block sizes. By always assimilating a newly freed block with adjacent free blocks, we maximize the size of each free memory area.</p>
<h3>Operation of malloc right after system startup</h3>
<p>As part of the system startup code, all of the heap has been cleared.</p>
<p>During the very first malloc operation, we start traversing the free list starting at index 0. The index of the next free block is 0, which means we're at the end of the list!</p>
<p>At this point, the malloc has a special test that checks if the current block index is 0, which it is. This special case initializes the free list to point at block index 1.</p>
<div class="fragment"><div class="line">   BEFORE                             AFTER</div><div class="line"></div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">0  |  0 |  0 |  0 |  0 |           0  |  1 |  0 |  1 |  0 |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">                                      +----+----+----+----+</div><div class="line">                                   1  |  0 |  0 |  0 |  0 |</div><div class="line">                                      +----+----+----+----+</div></div><!-- fragment --><p>The heap is now ready to complete the first malloc operation.</p>
<h3>Operation of malloc when we have reached the end of the free list and</h3>
<p>there is no block large enough to accommodate the request.</p>
<p>This happens at the very first malloc operation, or any time the free list is traversed and no free block large enough for the request is found.</p>
<p>The current block pointer will be at the end of the free list, and we know we're at the end of the list because the nf index is 0, like this:</p>
<div class="fragment"><div class="line">   BEFORE                             AFTER</div><div class="line"></div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">pf |*?? | ?? | cf | ?? |           pf |*?? | ?? | lf | ?? |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">            ...                                ...</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line"> p | cf | ?? |   ...   |            p | cf | ?? |   ...   |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">   +----+----+----+----+              +----+----+----+----+  </div><div class="line">cf |  0 |  p |  0 | pf |            c | lf |  p |   ...   | </div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">                                      +----+----+----+----+</div><div class="line">                                   lf |  0 | cf |  0 | pf |</div><div class="line">                                      +----+----+----+----+</div></div><!-- fragment --><p>As we walk the free list looking for a block of size b or larger, we get to cf, which is the last item in the free list. We know this because the next index is 0.</p>
<p>So we're going to turn cf into the new block of memory, and then create a new block that represents the last free entry (lf) and adjust the prev index of lf to point at the block we just created. We also need to adjust the next index of the new block (c) to point to the last free block.</p>
<p>Note that the next free index of the pf block must point to the new lf because cf is no longer a free block!</p>
<h3>Operation of malloc when we have found a block (cf) that will fit the current request of b units exactly</h3>
<p>This one is pretty easy, just clear the free list bit in the current block and unhook it from the free list.</p>
<div class="fragment"><div class="line">   BEFORE                             AFTER</div><div class="line"></div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">pf |*?? | ?? | cf | ?? |           pf |*?? | ?? | nf | ?? |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">            ...                                ...</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line"> p | cf | ?? |   ...   |            p | cf | ?? |   ...   |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">   +----+----+----+----+              +----+----+----+----+  Clear the free</div><div class="line">cf |* n |  p | nf | pf |           cf |  n |  p |   ..    |  list bit here</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line"> n | ?? | cf |   ...   |            n | ?? | cf |   ...   |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">            ...                                ...</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">nf |*?? | ?? | ?? | cf |           nf | ?? | ?? | ?? | pf |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div></div><!-- fragment --><p>Unhooking from the free list is accomplished by adjusting the next and prev free list index values in the pf and nf blocks.</p>
<h3>Operation of malloc when we have found a block that will fit the current request of b units with some left over</h3>
<p>We'll allocate the new block at the END of the current free block so we don't have to change ANY free list pointers.</p>
<div class="fragment"><div class="line">   BEFORE                             AFTER</div><div class="line"></div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">pf |*?? | ?? | cf | ?? |           pf |*?? | ?? | cf | ?? |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">            ...                                ...</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line"> p | cf | ?? |   ...   |            p | cf | ?? |   ...   |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">cf |* n |  p | nf | pf |           cf |* c |  p | nf | pf |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">                                      +----+----+----+----+ This is the new</div><div class="line">                                    c |  n | cf |   ..    | block at cf+b</div><div class="line">                                      +----+----+----+----+</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line"> n | ?? | cf |   ...   |            n | ?? |  c |   ...   |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">            ...                                ...</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">nf |*?? | ?? | ?? | cf |           nf | ?? | ?? | ?? | pf |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div></div><!-- fragment --><p>This one is prety easy too, except we don't need to mess with the free list indexes at all becasue we'll allocate the new block at the end of the current free block. We do, however have to adjust the indexes in cf, c, and n.</p>
<p>That covers the initialization and all possible malloc scenarios, so now we need to cover the free operation possibilities...</p>
<h3>Free Scenarios</h3>
<p>The operation of free depends on the position of the current block being freed relative to free list items immediately above or below it. The code works like this:</p>
<div class="fragment"><div class="line">if next block is free</div><div class="line">    assimilate with next block already on free list</div><div class="line">if prev block is free</div><div class="line">    assimilate with prev block already on free list</div><div class="line">else</div><div class="line">    put current block at head of free list</div></div><!-- fragment --><p>Step 1 of the free operation checks if the next block is free, and if it is then insert this block into the free list and assimilate the next block with this one.</p>
<p>Note that c is the block we are freeing up, cf is the free block that follows it.</p>
<div class="fragment"><div class="line">   BEFORE                             AFTER</div><div class="line"></div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">pf |*?? | ?? | cf | ?? |           pf |*?? | ?? | nf | ?? |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">            ...                                ...</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line"> p |  c | ?? |   ...   |            p |  c | ?? |   ...   |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">   +----+----+----+----+              +----+----+----+----+ This block is</div><div class="line"> c | cf |  p |   ...   |            c | nn |  p |   ...   | disconnected</div><div class="line">   +----+----+----+----+              +----+----+----+----+ from free list,</div><div class="line">   +----+----+----+----+                                    assimilated with</div><div class="line">cf |*nn |  c | nf | pf |                                    the next, and</div><div class="line">   +----+----+----+----+                                    ready for step 2</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">nn | ?? | cf | ?? | ?? |           nn | ?? |  c |   ...   |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">            ...                                ...</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">nf |*?? | ?? | ?? | cf |           nf |*?? | ?? | ?? | pf |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div></div><!-- fragment --><p>Take special note that the newly assimilated block (c) is completely disconnected from the free list, and it does not have its free list bit set. This is important as we move on to step 2 of the procedure...</p>
<p>Step 2 of the free operation checks if the prev block is free, and if it is then assimilate it with this block.</p>
<p>Note that c is the block we are freeing up, pf is the free block that precedes it.</p>
<div class="fragment"><div class="line">   BEFORE                             AFTER</div><div class="line"></div><div class="line">   +----+----+----+----+              +----+----+----+----+ This block has</div><div class="line">pf |* c | ?? | nf | ?? |           pf |* n | ?? | nf | ?? | assimilated the</div><div class="line">   +----+----+----+----+              +----+----+----+----+ current block</div><div class="line">   +----+----+----+----+</div><div class="line"> c |  n | pf |   ...   |</div><div class="line">   +----+----+----+----+</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line"> n | ?? |  c |   ...   |            n | ?? | pf | ?? | ?? |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">            ...                                ...</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">nf |*?? | ?? | ?? | pf |           nf |*?? | ?? | ?? | pf |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div></div><!-- fragment --><p>Nothing magic here, except that when we're done, the current block (c) is gone since it's been absorbed into the previous free block. Note that the previous step guarantees that the next block (n) is not free.</p>
<p>Step 3 of the free operation only runs if the previous block is not free. it just inserts the current block to the head of the free list.</p>
<p>Remember, 0 is always the first block in the memory heap, and it's always head of the free list!</p>
<div class="fragment"><div class="line">   BEFORE                             AFTER</div><div class="line"></div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line"> 0 | ?? | ?? | nf |  0 |            0 | ?? | ?? |  c |  0 |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">            ...                                ...</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line"> p |  c | ?? |   ...   |            p |  c | ?? |   ...   |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line"> c |  n |  p |   ..    |            c |* n |  p | nf |  0 |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line"> n | ?? |  c |   ...   |            n | ?? |  c |   ...   |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">            ...                                ...</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">nf |*?? | ?? | ?? |  0 |           nf |*?? | ?? | ?? |  c |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div></div><!-- fragment --><p>Again, nothing spectacular here, we're simply adjusting a few pointers to make the most recently freed block the first item in the free list.</p>
<p>That's because finding the previous free block would mean a reverse traversal of blocks until we found a free one, and it's just easier to put it at the head of the list. No traversal is needed.</p>
<h3>Realloc Scenarios</h3>
<p>Finally, we can cover realloc, which has the following basic operation.</p>
<p>The first thing we do is assimilate up with the next free block of memory if possible. This step might help if we're resizing to a bigger block of memory. It also helps if we're downsizing and creating a new free block with the leftover memory.</p>
<p>First we check to see if the next block is free, and we assimilate it to this block if it is. If the previous block is also free, and if combining it with the current block would satisfy the request, then we assimilate with that block and move the current data down to the new location.</p>
<p>Assimilating with the previous free block and moving the data works like this:</p>
<div class="fragment"><div class="line">   BEFORE                             AFTER</div><div class="line"></div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">pf |*?? | ?? | cf | ?? |           pf |*?? | ?? | nf | ?? |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">            ...                                ...</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">cf |* c | ?? | nf | pf |            c |  n | ?? |   ...   | The data gets</div><div class="line">   +----+----+----+----+              +----+----+----+----+ moved from c to</div><div class="line">   +----+----+----+----+                                    the new data area  </div><div class="line"> c |  n | cf |   ...   |                                    in cf, then c is</div><div class="line">   +----+----+----+----+                                    adjusted to cf</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line"> n | ?? |  c |   ...   |            n | ?? |  c | ?? | ?? |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">            ...                                ...</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">nf |*?? | ?? | ?? | cf |           nf |*?? | ?? | ?? | pf |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div></div><!-- fragment --><p>Once we're done that, there are three scenarios to consider:</p>
<ol type="1">
<li>The current block size is exactly the right size, so no more work is needed.</li>
<li>The current block is bigger than the new required size, so carve off the excess and add it to the free list.</li>
<li>The current block is still smaller than the required size, so malloc a new block of the correct size and copy the current data into the new block before freeing the current block.</li>
</ol>
<p>The only one of these scenarios that involves an operation that has not yet been described is the second one, and it's shown below:</p>
<div class="fragment"><div class="line">BEFORE                             AFTER</div><div class="line"></div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line"> p |  c | ?? |   ...   |            p |  c | ?? |   ...   |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line"> c |  n |  p |   ...   |            c |  s |  p |   ...   |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line">                                      +----+----+----+----+ This is the</div><div class="line">                                    s |  n |  c |   ..    | new block at</div><div class="line">                                      +----+----+----+----+ c+blocks</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div><div class="line"> n | ?? |  c |   ...   |            n | ?? |  s |   ...   |</div><div class="line">   +----+----+----+----+              +----+----+----+----+</div></div><!-- fragment --><p>Then we call <a class="el" href="_e_s_p8266_a_v_r_i_s_p_8cpp.html#a2c6efa7679f8cd9f61af96e105017560">free()</a> with the adress of the data portion of the new block (s) which adds it to the free list. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
